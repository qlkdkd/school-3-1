# 1. 알고리즘 개요
* 알고리즘: 해결해야 할 어떤 문제가 주어졌을 때, 이 문제의 해답을 구하기 위한 절차를 순서대로 명확하게 나타낸 것
![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/93bcf408-8764-4dbd-b8dc-4ff1bcdc4e15)

## 1.1. 알고리즘이란
*주어진 문제를 해결하기 위한 단계적인 절차
  * 알고리즘은 c언어나 java, 파이썬 등과 같은 프로그래밍 언어와 상관없이 문제 해결 절차를 나타내는 명령어의 집합

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/83840210-0571-48bd-998d-e81134294c09)

### 알고리즘의 조건
* 입력: 알고리즘이 입력을 받는다면 모호하지 않고 잘 정의된 입력이어야 한다. 알고리즘은 0개 이상의 입력을 갖는다.
* 출력: 출력은 명확하게 정의되어야 하며 1개 이상의 출력이 반드시 존재하여야 한다.
* 명확성: 각 명령어의 의미는 모호하지 않고 명확해야 한다.
* 유한성: 한정된 수의 단계 후에는 반드시 종료되어야 한다. 즉, 무한루프나 이와 유사한 상태로 끝나서는 안된다.
* 유효성: 명령어들은 현재 실행 가능한 연산이어야 한다. 미래에 개발될 기술 등을 포함해서는 안된다.

### 알고리즘의 기술 방법
1. 자연어
2. 흐름도(flow chart)
3. 유사 코드(pseudo-code)
4. 특정한 프로그래밍 언어

### 알고리즘의 기술 예제1. : 배열에서 최댓값을 찾는 알고리즘
1. 자연어 표현
```
1. 리스트 A의 첫 번째 항목을 변수 max에 복사한다.
2. 리스트 A의 다음 항목들을 차례대로 max와 비교하여, max보다 더 크면 그 값을 max로 복사한다.
3. 배열 A의 모든 요소를 비교했으면 max를 반환한다.
```
* 표현이 자유롭고 편리하다는 장점
* 자칫 문장의 의미가 애매해질 수 있음-> 사용되는 단어들의 의미를 정확히 해야 함

2. 흐름도
* 알고리즘의 절차를 가장 잘 정확하게 표현할 수 있어 특허 명세서 등에 많이 사용됨
* 알고리즘이 조금만 길어져도 그림이 너무 복잡해져 혼란스러워질 수 있음
![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/a268fc90-6ea7-4ac1-bc11-d9a066b5e193)

3. 유사코드
```
find_max(A)
  max<-A[0]
  for i<-1 to size(A) do
    if A[i]>max then
      max<-A[i]
  return max
```
* 자연어보다는 체계적이지만 프로그래밍 언어보다는 덜 엄격한 방법
* 대입 연산자로 '<-' 사용

4. 특정한 프로그래밍 언어(예: C언어)
```c
int find_max(int A[], int n){
  int i, tmp=A[0];
  for(i=1; i<n; i++){
    if(A[i]>tmp){
      tmp=A[i];
    }
  }
  return tmp;
}
```
* 특정 프로그래밍 언어를 사용하면 알고리즘을 실행해볼 수 있음
* 문법을 정확히 따라야 하므로 언어의 특징에 따른 많은 불필요한 표현들이 알고리즘 기술에 포함되어야 함

### 파이썬을 이용한 알고리즘 기술
```python
def find_max(A):
    max=A[0]
    for i in range(len(A)):
        if A[i]>max:
            max=A[i]
    return max
```
* 파이썬 코드는 유사코드와 매우 유사
* 바로 실행 가능

### 알고리즘의 기술 예제2: 최대공약수 문제
* 알고리즘 1. 정의를 직접 이용

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/27d30d2a-e527-4f1f-8e60-82aa5599396e)
```
gcd(a, b)
1. a의 약수를 모두 찾아 리스트 alist에 저장한다
2. b의 약수를 모두 찾아 리스트 blist에 저장한다
3. alist와 blist에 공통적으로 들어 있는 가장 큰 숫자를 찾아 반환한다.
```

* 알고리즈 2. 한 수의 약수만 구함

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/e1e0b03b-9686-4487-9d8c-cde3599eccdf)
```
gcd(a, b)
1. a의 약수를 모두 찾아 리스트 alist에 저장한다.
2. alist의 가장 큰 수부터 차례대로 b의 약수인지를 검사한다. 만약 b의 약수이기도 하면 이 숫자를 반환한다.
3. 이 과정을 alist의 모든 숫자에 대해 반복한다.
```

* 알고리즘 3. 유클리드 알고리즘
![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/5cadbe4c-85c6-418e-a8c0-5d32e2dd0862)
```python
def gcd(a, b):
    while b!=0:
        r=a%b
        a=b
        b=r
    return a
```

### 알고리즘은
* 알고리즘은 여러 가지 방법으로 표현할 수 있다.
* 하나의 문제를 해결하기 위해 여러가지 알고리즘이 가능하다.
* 동일한 문제에 대해 매우 다른 전략을 기반으로 알고리즘을 작성할 수 있고, 이들은 매우 다른 속도로 문제를 해결할 수 있다.
* 알고리즘의 정확한 동작을 위해 제한 조건이나 입력의 범위를 신중하게 고려해야 한다.
  * 예: 유클리드 알고리즘에서는 a가 b보다 커야 한다.
 
## 1.2 문제 해결 과정
* 알고리즘 개발 과정

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/a9802815-c31a-4221-ac0e-8dbabf0e302d)

### 문제의 이해
* 문제를 정확히 이해하는 것이 가장 중요
  * 간단한 입력 예에 대한 해를 구해보고, 좀 더 특별한 경우에 대해서도 생각해 보아야 함

* 입력은 주어진 문제의 하나의 사례
  * 입력의 범위 정확히 해야 함
  * 올바른 알고리즘은 "대부분의 입력"이 아니라 "모든 유효한 입력"에 대해 정확한 해답을 구함
 
* 알고리즘 설계 전 결정해햐 할 사례들
  * 순서적 알고리즘/병렬처리 알고리즘
 
### 알고리즘 설계 기법들
* 억지 기법과 완전 탐색: 원하는 답을 구할 때까지 모든 가능한 경우를 테스트
* 축소 정복: 주어진 문제를 하나의 좀 더 작은 문제로 축소하여 해결하는 방법
* 분할 정봅: 주어진 문제를 여러 개의 더 작은 문제로 반복적으로 분할하여 해결 가능한 충분히 작은 문제로 만든 다음 해결. 이후 해결된 결과를 병합하는 방법으로 원래의 문제를 해결
* 공간을 이용해 시간을 버는 전략: 추가적인 공간을 사용하여 처리시간을 줄이는 전략
* 동적 계획법: 작은 문제를 먼저 해결하고 결과를 '저장'하여 다음에 더 큰 문제를 해결할 때 사용한다는 것
* 탐욕적 기법: 어떤 결정을 해야 할 때마다 "그 순간에 최적"이라고 생각되는 것을 선택하는 방법
* 백트래킹과 분기 한정 기법: 상태공간트리에서 해를 단계적으로 찾아가는 과정에서 현재의 해가 최종 해가 될 수 없다고 판단되면 더 이상 탐색하지 않고 되돌아가서 다른 후보해를 탐색하는 방법. 더 많은 가지치기를 통한 탐색 효율을 높이기 위해 분기 한정 기법을 추가로 사용할 수 있음

### 알고리즘의 정확성
* 실험적 분석
  * 다양한 입력 적용
  * 충분한 테스트가 어느 정도인지를 알 수 없음
  * 알고리즘이 틀렸다는 것을 보여주기 위해서는 한 가지 입력 사례만으로 충분함
 
* 증명적인 분석
  * 수학적인 방법으로 알고리즘의 타당성을 증명
  * 수학적 귀밥덥 등이 자주 사용
  * 증명이 매우 어려울 수도 있음
 
### 알고리즘의 분석과 구현
* 알고리즘의 효율성 분석
  * 시간 효율성: 가장 중요하게 생각되는 알고리즘 평가 요소로 더 빨리 결과를 내는 알고리즘이 더 효율적
  * 공간 효율성: 알고리즘이 컴퓨터 메모리를 얼마나 많이 사용하는지를 나타냄. 동일한 문제를 위한 알고리즘이라도 더 적은 메모리를 사옹하는 것이 공간 효율성이 더 높음
  * 코드 효율성: 알고리즘을 기술한 코드가 얼마나 이해하기 쉬운가를 나타냄
 
* 알고리즘의 구현
  * 컴파일 언어: 실행 효율 높임
  * 인터프리터 언어: 빠른 구현과 알고리즘 동작 확인
 
## 1.3. 중요한 문제의 유형들
* 정렬
  * 데이터를 순서대로 제배열하는 작업
  * 오름차순/내림차순
  * 레코드: 정렬할 대상, 정렬 키: 정렬의 기준이 되는 필드(하나의 레코드는 여러개의 필드로 구성)-> 정렬이란 레코드를 키의 순서로 재배열하는 것
  * 비교기반: 기법들이 최소한 $nlogn$에 비례하는 연산이 필요, 분배기반: 이보다 빠른 정렬 가능, 그러나 적용할 수 있는 킷값에 제한 있음
  * 안정성: 정렬 후에도 이들의 상대적인 위치가 바뀌지 않는 경우 안정성을 갖는 정렬이라 함
  * 제자리 정렬: 어떤 정렬 알고리즘이 입력 배열 외에 추가적인 메모리를 사용하지 않는다면 이를 제자리 정렬이라 함
 
* 탐색
  * 레코드의 집합에서 "탐색키"라 불리는 원하는 값을 가진 레코드를 찾는 작업
  * 순차탐색: 항목을 하나씩 순서적으로 찾는 방법
  * 이진탐색, 해싱: 대규모 데이터베이스에서 정보를 효율적으로 찾아내기 위해서 사용하는 방법

* 문자열 처리
  * 문자열: 문자들의 시퀀스
  * 텍스트 문자열: 알파벳이나 숫자들로 구성
  * 비트 문자열: 0과 1로 구성
  * 유전 시퀀스: {A, C, G, T}를 이용한 문자열
  * 문자열 매칭: 텍스트에서 어떤 단어를 찾는 것
 
* 그래프 문제
  * 그래프: 연결된 객체들 사이의 관계를 표현할 수 있는 자료구조
  * 다양한 객체(정점)들이 서로 복잡하게 연결(간선)되어 있는 구조를 표현할 수 있는 자료구조
  * 순회: 모든 정점을 빠짐없이 방문
  * 위상 정렬: 방향 그래프
  * 최단 경로: 두 도시 사이의 가장 빠른 경로를 찾는 것
  * 최소 비용의 신장트리
  * 
