# 2. 알고리즘 효율성 분석
* 시간 효율성: 더 빨리 결과를 내는 알고리즘이 더 효율적
* 공간 효율성: 알고리즘이 컴퓨터 메모리를 얼마나 사용하는지를 나타냄.
* 둘 중에서 하나를 골라야 한다면 보통은 시간 효율성을 선택함

## 2.1. 효율성 분석의 기초
### 실제 실행 시간 측정 방법
![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/772de859-99c9-4101-ae15-38652338827e)
* 실행 시간 측정 방법의 문제점
  * 알고리즘 반드시 구현해야 함
  * 반드시 같은 조건의 하드웨어를 사용하여 실행시간을 측정해야 함
  * 프로그래밍 언어나 운영체제와 같은 소프트웨어 환경도 같아야 함
  * 성능 비교에 사용했던 데이터가 아닌 다른 데이터에 대해서는 다른 결과가 나올 수 있어 실험되지 않은 입력에 대해서는 실행시간을 주장할 수 없음

* 알고리즘의 효율성 평가를 위해 절대적인 시간 측정이 아니라 이론적으로 알고리즘의 복잡도를 분석하는 방법이 주로 사용됨

### 알고리즘 복잡도 분석에서 중요한 점
1. 입력의 크기
  * 알고리즘의 효율성은 보통 입력의 크기의 함수로 표현됨
  * 무엇이 입력의 크기를 나타내는지를 먼저 명확히 결정
    * 예1: 리스트 A에서 어떤 값(key)를 가진 항목을 찾는 탐색 문제에서 입력의 크기: `len(A)`
    * 예2: x의 n제곱 값인 $x^n$을 구하는 거듭제곱 알고리즘의 입력의 크기: n
      * x가 크다고 처리시간이 늘어나진 않음
    * 예3: 다항식의 연산: 다항식의 최대차수 b
    * 예4: 가로가 W, 세로가 H인 행렬 알고리즘: W, H
    * 예5: 그래프 연산: V, E
   
2. 기본 연산
  * 알고리즘에서 가장 많이 실행되는 연산, 즉 기본 연산을 찾고, 이 연산이 실행되는 횟수만을 계산하는 것
  * 다중 루프의 경우 가장 안쪽 루프에 있는 연산이 가장 많이 실행

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/f5017592-21cd-4870-bffb-5bb72e1dcc72)
  * 알고리즘 A: 곱셈(\*)과 대입(<-)연산이 각각 한 번씩 사용됨-> 총 2회의 계산
  * 알고리즘 B:
    * 반복문 내부의 문장인 3행은 덧셈과 대입 연산이 각각 한번씩 필요
    * 2행에 의해 n번 반복됨->(대입 n번, 덧셈 n번)
    * sum을 초기화하는 문장에서도 한 번의 대입 필요
    * 총 2n+1번의 계산
  * 알고리즘 C:
    * 덧셈 연산: $n^2$번
    * 대입 연산: $n^2+n+2$,번
    * 총 $2n^2+n+2$번
   
3. 복잡도 함수와 증가 속도
  * 시간 복잡도 함수: 연산의 수를 n의 함수로 나타낸 것
  * 위 알고리즘의 시간복잡도 함수를 각각 $T_A(n)$, $T_B(N)$, $T_C(N)$이라고 나타내면
$$T_A(n)=2, T_B(n)=2n, T_C(n)=2n^2$$
  * 알고리즘의 효율성 분석은 충분히 큰($n>=n_0)$ 입력에 대해서만 관심이 있음

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/7c77bdb0-c1fd-4983-944e-47eed8e6ad70)
