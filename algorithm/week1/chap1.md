# 1. 알고리즘 개요
* 알고리즘: 해결해야 할 어떤 문제가 주어졌을 때, 이 문제의 해답을 구하기 위한 절차를 순서대로 명확하게 나타낸 것
![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/93bcf408-8764-4dbd-b8dc-4ff1bcdc4e15)

## 1.1. 알고리즘이란
*주어진 문제를 해결하기 위한 단계적인 절차
  * 알고리즘은 c언어나 java, 파이썬 등과 같은 프로그래밍 언어와 상관없이 문제 해결 절차를 나타내는 명령어의 집합

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/83840210-0571-48bd-998d-e81134294c09)

### 알고리즘의 조건
* 입력: 알고리즘이 입력을 받는다면 모호하지 않고 잘 정의된 입력이어야 한다. 알고리즘은 0개 이상의 입력을 갖는다.
* 출력: 출력은 명확하게 정의되어야 하며 1개 이상의 출력이 반드시 존재하여야 한다.
* 명확성: 각 명령어의 의미는 모호하지 않고 명확해야 한다.
* 유한성: 한정된 수의 단계 후에는 반드시 종료되어야 한다. 즉, 무한루프나 이와 유사한 상태로 끝나서는 안된다.
* 유효성: 명령어들은 현재 실행 가능한 연산이어야 한다. 미래에 개발될 기술 등을 포함해서는 안된다.

### 알고리즘의 기술 방법
1. 자연어
2. 흐름도(flow chart)
3. 유사 코드(pseudo-code)
4. 특정한 프로그래밍 언어

### 알고리즘의 기술 예제1. : 배열에서 최댓값을 찾는 알고리즘
1. 자연어 표현
```
1. 리스트 A의 첫 번째 항목을 변수 max에 복사한다.
2. 리스트 A의 다음 항목들을 차례대로 max와 비교하여, max보다 더 크면 그 값을 max로 복사한다.
3. 배열 A의 모든 요소를 비교했으면 max를 반환한다.
```
* 표현이 자유롭고 편리하다는 장점
* 자칫 문장의 의미가 애매해질 수 있음-> 사용되는 단어들의 의미를 정확히 해야 함

2. 흐름도
* 알고리즘의 절차를 가장 잘 정확하게 표현할 수 있어 특허 명세서 등에 많이 사용됨
* 알고리즘이 조금만 길어져도 그림이 너무 복잡해져 혼란스러워질 수 있음
![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/a268fc90-6ea7-4ac1-bc11-d9a066b5e193)

3. 유사코드
```
find_max(A)
  max<-A[0]
  for i<-1 to size(A) do
    if A[i]>max then
      max<-A[i]
  return max
```
* 자연어보다는 체계적이지만 프로그래밍 언어보다는 덜 엄격한 방법
* 대입 연산자로 '<-' 사용

4. 특정한 프로그래밍 언어(예: C언어)
```c
int find_max(int A[], int n){
  int i, tmp=A[0];
  for(i=1; i<n; i++){
    if(A[i]>tmp){
      tmp=A[i];
    }
  }
  return tmp;
}
```
* 특정 프로그래밍 언어를 사용하면 알고리즘을 실행해볼 수 있음
* 문법을 정확히 따라야 하므로 언어의 특징에 따른 많은 불필요한 표현들이 알고리즘 기술에 포함되어야 함

### 파이썬을 이용한 알고리즘 기술
```python
def find_max(A):
    max=A[0]
    for i in range(len(A)):
        if A[i]>max:
            max=A[i]
    return max
```
* 파이썬 코드는 유사코드와 매우 유사
* 바로 실행 가능

### 알고리즘의 기술 예제2: 최대공약수 문제
* 알고리즘 1. 정의를 직접 이용

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/27d30d2a-e527-4f1f-8e60-82aa5599396e)
```
gcd(a, b)
1. a의 약수를 모두 찾아 리스트 alist에 저장한다
2. b의 약수를 모두 찾아 리스트 blist에 저장한다
3. alist와 blist에 공통적으로 들어 있는 가장 큰 숫자를 찾아 반환한다.
```

* 알고리즈 2. 한 수의 약수만 구함

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/e1e0b03b-9686-4487-9d8c-cde3599eccdf)
```
gcd(a, b)
1. a의 약수를 모두 찾아 리스트 alist에 저장한다.
2. alist의 가장 큰 수부터 차례대로 b의 약수인지를 검사한다. 만약 b의 약수이기도 하면 이 숫자를 반환한다.
3. 이 과정을 alist의 모든 숫자에 대해 반복한다.
```

* 알고리즘 3. 유클리드 알고리즘
![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/5cadbe4c-85c6-418e-a8c0-5d32e2dd0862)
```python
def gcd(a, b):
    while b!=0:
        r=a%b
        a=b
        b=r
    return a
```

### 알고리즘은
* 알고리즘은 여러 가지 방법으로 표현할 수 있다.
* 하나의 문제를 해결하기 위해 여러가지 알고리즘이 가능하다.
* 동일한 문제에 대해 매우 다른 전략을 기반으로 알고리즘을 작성할 수 있고, 이들은 매우 다른 속도로 문제를 해결할 수 있다.
* 알고리즘의 정확한 동작을 위해 제한 조건이나 입력의 범위를 신중하게 고려해야 한다.
  * 예: 유클리드 알고리즘에서는 a가 b보다 커야 한다.
 
## 1.2 문제 해결 과정
* 알고리즘 개발 과정

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/a9802815-c31a-4221-ac0e-8dbabf0e302d)

### 문제의 이해
* 문제를 정확히 이해하는 것이 가장 중요
  * 간단한 입력 예에 대한 해를 구해보고, 좀 더 특별한 경우에 대해서도 생각해 보아야 함

* 입력은 주어진 문제의 하나의 사례
  * 입력의 범위 정확히 해야 함
  * 올바른 알고리즘은 "대부분의 입력"이 아니라 "모든 유효한 입력"에 대해 정확한 해답을 구함
 
* 알고리즘 설계 전 결정해햐 할 사례들
  * 순서적 알고리즘/병렬처리 알고리즘
 
### 알고리즘 설계 기법들
* 억지 기법과 완전 탐색: 원하는 답을 구할 때까지 모든 가능한 경우를 테스트
* 축소 정복: 주어진 문제를 하나의 좀 더 작은 문제로 축소하여 해결하는 방법
* 분할 정봅: 주어진 문제를 여러 개의 더 작은 문제로 반복적으로 분할하여 해결 가능한 충분히 작은 문제로 만든 다음 해결. 이후 해결된 결과를 병합하는 방법으로 원래의 문제를 해결
* 공간을 이용해 시간을 버는 전략: 추가적인 공간을 사용하여 처리시간을 줄이는 전략
* 동적 계획법: 작은 문제를 먼저 해결하고 결과를 '저장'하여 다음에 더 큰 문제를 해결할 때 사용한다는 것
* 탐욕적 기법: 어떤 결정을 해야 할 때마다 "그 순간에 최적"이라고 생각되는 것을 선택하는 방법
* 백트래킹과 분기 한정 기법: 상태공간트리에서 해를 단계적으로 찾아가는 과정에서 현재의 해가 최종 해가 될 수 없다고 판단되면 더 이상 탐색하지 않고 되돌아가서 다른 후보해를 탐색하는 방법. 더 많은 가지치기를 통한 탐색 효율을 높이기 위해 분기 한정 기법을 추가로 사용할 수 있음

### 알고리즘의 정확성
* 실험적 분석
  * 다양한 입력 적용
  * 충분한 테스트가 어느 정도인지를 알 수 없음
  * 알고리즘이 틀렸다는 것을 보여주기 위해서는 한 가지 입력 사례만으로 충분함
 
* 증명적인 분석
  * 수학적인 방법으로 알고리즘의 타당성을 증명
  * 수학적 귀밥덥 등이 자주 사용
  * 증명이 매우 어려울 수도 있음
 
### 알고리즘의 분석과 구현
* 알고리즘의 효율성 분석
  * 시간 효율성: 가장 중요하게 생각되는 알고리즘 평가 요소로 더 빨리 결과를 내는 알고리즘이 더 효율적
  * 공간 효율성: 알고리즘이 컴퓨터 메모리를 얼마나 많이 사용하는지를 나타냄. 동일한 문제를 위한 알고리즘이라도 더 적은 메모리를 사옹하는 것이 공간 효율성이 더 높음
  * 코드 효율성: 알고리즘을 기술한 코드가 얼마나 이해하기 쉬운가를 나타냄
 
* 알고리즘의 구현
  * 컴파일 언어: 실행 효율 높임
  * 인터프리터 언어: 빠른 구현과 알고리즘 동작 확인
 
## 1.3. 중요한 문제의 유형들
* 정렬
  * 데이터를 순서대로 제배열하는 작업
  * 오름차순/내림차순
  * 레코드: 정렬할 대상, 정렬 키: 정렬의 기준이 되는 필드(하나의 레코드는 여러개의 필드로 구성)-> 정렬이란 레코드를 키의 순서로 재배열하는 것
  * 비교기반: 기법들이 최소한 $nlogn$에 비례하는 연산이 필요, 분배기반: 이보다 빠른 정렬 가능, 그러나 적용할 수 있는 킷값에 제한 있음
  * 안정성: 정렬 후에도 이들의 상대적인 위치가 바뀌지 않는 경우 안정성을 갖는 정렬이라 함
  * 제자리 정렬: 어떤 정렬 알고리즘이 입력 배열 외에 추가적인 메모리를 사용하지 않는다면 이를 제자리 정렬이라 함
 
* 탐색
  * 레코드의 집합에서 "탐색키"라 불리는 원하는 값을 가진 레코드를 찾는 작업
  * 순차탐색: 항목을 하나씩 순서적으로 찾는 방법
  * 이진탐색, 해싱: 대규모 데이터베이스에서 정보를 효율적으로 찾아내기 위해서 사용하는 방법

* 문자열 처리
  * 문자열: 문자들의 시퀀스
  * 텍스트 문자열: 알파벳이나 숫자들로 구성
  * 비트 문자열: 0과 1로 구성
  * 유전 시퀀스: {A, C, G, T}를 이용한 문자열
  * 문자열 매칭: 텍스트에서 어떤 단어를 찾는 것
 
* 그래프 문제
  * 그래프: 연결된 객체들 사이의 관계를 표현할 수 있는 자료구조
  * 다양한 객체(정점)들이 서로 복잡하게 연결(간선)되어 있는 구조를 표현할 수 있는 자료구조
  * 순회: 모든 정점을 빠짐없이 방문
  * 위상 정렬: 방향 그래프
  * 최단 경로: 두 도시 사이의 가장 빠른 경로를 찾는 것
  * 최소 비용의 신장트리
  * TSP(외판원 문제): 모든 도시를 정확히 한 번 방문하는 최단 경로를 찾는 문제
  * Graph coloring(그래프 색칠): 인접한 두 정점이 같은 색이 되지 않도록 그래프의 모든 정점을 가장 적은 수의 색으로 칠하는 문제

* 조합 문제
  * 어떤 조건을 만족하는 순열이나 조합 또는 부분집합과 같은 조합 객체를 찾는 문제
  * 예: TSP문제: 모든 가능한 경로(조합 객체) 중에서 최단 경로란 추가적인 특성을 갖는 조합 객체를 찾는 문제
  * 보통 조합 객체의 수는 일반적으로 문제의 크기에 따라 매우 빠르게 증가
 
## 1.4. 기본적인 자료구조와 파이썬
* 자료구조: 컴퓨터에서 자료들을 정리하고 조직화하는 여러 가지 구조
* 알고리즘의 설계에 큰 영향을 미침
* 단순 자료구조: 정수나 실수, 문자와 같이 대부분의 프로그래밍 언어에서 기본적으로 제공
* 복합 자료구조: 여러개의 자료를 모은 창고

### 배열 구조와 연결된 구조
* 배열 구조
  * 항목들을 인접한 메모리 공간에 나열하는 구조
  * 직접 접근 방법 지원: i번째 항목A[i]의 위치를 한 번에 계산하여 바로 접근
* 연결된 구조
  * 메모리 공간에 흩어진 자료들을 연결고리(링크)를 이용해 연결한 구조
  * 순저 접근 방법 지원: i번째 항목의 위치를 한번에 계산할 수 없는 대신 용량의 변경이나 항목의 추가 및 삭제가 쉬움

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/900fd279-27d4-42a3-a97a-fade368144fa)

### 선형 자료구조
### 리스트
* 항목들이 차례대로 나열되어 있는 선형 자료구조
* 리스트의 항목들 순서 또는 위치를 가짐

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/9ad3fe73-4c01-4d3c-b7c3-43049d9c6a32)
```python
A=[1, 2, 3,4 ,5]

print(A[0])#0번째 항목 출력

print(len(A))# 리스트 A의 길이 출력

A.append(9)#리스트 맨 뒤에 9 추가
print(A)

A.pop(2)#2번째 항목(3) 삭제
print(A)
```

### 스택
* 입출력이 후입선출(LIFO: Last In First Out)형태로 일어나는 자료구조
* 리스트에서 항목 접근을 위한 다른 통로들은 모두 막고 한쪽만을 열어둔 구조
![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/ba1400b3-225b-49f5-9f9a-4e6add9905f0)
> 파이썬에서의 스택
> * 삽입: append()
> * 삭제: pop()

### 큐
* 입출력이 선입선출(FIFO: First In First Out)
* 새로운 데이터가 추가되고 앞에서 데이터가 하나씩 삭제되는 구조를 가지고 있음
* 삽입이 일어나는 곳: rear, 삭제가 일어나는 곳: front

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/0349dc54-c155-4d44-a935-ba23fbf4f638)

* 파이썬에서의 스택과 큐
```python
import queue#파이썬 큐 모듈 포함

Q=queue.Queue(maxsize=20)#큐 객체 생성(최대 크기 20)
S=queue.LifoQueue(maxsize=20)#스택 객체 생성(최대 크기 20)

Q.put(20)#큐에 20 삽입(enqueue)
print(Q)

val=Q.get()#큐에서 항목 삭제(dequeue)
print(val, Q)

S.put(20)#스택에 20 삽입(push)
print(S)

val2=S.put(20)#스택에서 항목 삭제(pop)
print(val2, S)
```

### 우선순위 큐
* 우선순위의 개념을 큐에 도입한 자료구조
* 모든 데이터가 우선순위를 가지고 있고, 들어온 순서와 상관없이 우선순위가 높은 데이터가 먼저 출력되는 구조
* 선형 자료구조 X
* 트리 구조를 사용하는 힙(heap)이 가장 효율적인 구현 방법
* 파이썬에서 힙을 이용한 우선순위 큐를 위해 heapq 모듈 제공
![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/b7cde8b4-2f24-4d74-aba4-cbe6e14aab9e)

### 그래프
* 연결결된 객체들 사이의 관계를 표현할 수 있는 가장 복잡한 형태의 자료구조
* 수학적으로 그래프는 G=(V, E)와 같이 표시
  * V(G): 그래프 G의 정점의 집합
  * E(G): 간선의 집합. 객체들 사이의 관계
#### 그래프의 종류
* 무방향 그래프: 간선에 방향이 표시되지 않은 그래프. 간선은 양방향으로 갈 수 있음. (A, B)와 (B, A)는 동일한 간선
* 방향 그래프: 간선에 방향성이 존재하는 그래프. 간선은 화살표로 표시되는데, 한 쪽 방향으로만 갈 수 있음. <A, B>는 정점 A에서 B로만 갈 수 있는 간선

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/de3e2b4f-92c9-40ce-95b7-dcb2ac8ded8d)

* 가중치 그래프: 간선에 비용이나 가중치가 할당된 그래프. 네트워크(network)라고도 함. 간선이 두 정점 사이의 연결 유무 뿐만 아니라 연결 강도까지 나타낼 수 있어 보다 복잡한 관계를 표현할 수 있음

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/17a87599-4b0b-4469-87ca-621404c50bce)

#### 그래프 용어
* 인접 정점(adjacent vertex): 간선에 의해 직접 연결된 정점
* 정점의 차수(degree): 그 정점에 연결된 간선의 수
  * 무방향 그래프: 인접한 정점의 수
  * 방향 그래프: 진입 차수(들어오는 간선의 수)와 진출 차수(외부로 나가는 간선의 수)로 세분화
* 경로(path): 간선을 따라갈 수 있는 길. 정점의 나열로 표시됨
* 경로의 길이: 경로를 구성하는데 사용된 간선의 수. 가중치 그래프의 경우 간선의 총 가중치의 합
* 단순 경로: 경로 중 반복되는 간선이 없는 경로
* 사이클: 단순 경로의 시작 정점과 종료 정점이 같은 경우
* 완전 그래프: 모든 정점 간에 간선이 존재하는 그래프. 그래프 정점의 수가 n일 때, 전체 간선의 수는 n(n-1)/2

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/82a82cda-18f0-41af-b2f4-81b9efabd90d)

### 트리
* 자유트리: 그래프의 일종으로 사이클이 없는 연결 그래프
* 루트를 가진 트리: 자유트리의 정점들 중에 하나를 루트로 선택하는 경우. "정점"대신 "노드"라는 용어를 더 많이 사용

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/a1a532db-678c-4c4a-8d23-c0bd29e44e77)

#### 트리 용어
![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/8c9c7179-7128-49f1-b574-e265175fb4cd)
* 루트노드: 계층적인 구조에서 가장 높은 곳에 있는 노드
* 부모 노드와 자식 노드: 간선으로 직접 연결된 노드 중에 상위 노드와 하위 노드
* 형제 노드: 동일한 부모를 가진 노드
* 조상 노드와 자손 노드: 어떤 노드에서 루트 노드까지의 경로상에 있는 모든 노드와 어떤 노드 하위에 연결된 모든 노드
* 단말 노드: 자식 노드가 없는 도드. 자식이 있으면 비단말 노드
* 노드의 차수: 어떤 노드가 가지고 있는 자식의 수
* 트리의 차수: 트리가 가지고 있는 모든 노드의 차수 중 가장 큰 차수
* 레벨: 트리의 각 층에 번호를 매기는 것. 루트의 레벨을 기준으로 한 층씩 내려갈수록 1씩 증가
* 트리의 높이: 트리가 가지고 있는 최대 레벨

#### 트리의 표현
* 일반 트리: 노드들이 임의의 개수의 자식을 가질 수 있는 트리
* 이진트리: 자식 노드의 개수가 항상 2개 이하인 트리

### 집합
* 원소들 사이에 순서가 없고, 중복을 허용하지 않음
  * 원소들이 어떤 위치를 가지지도 않고, 일렬로 나열한다는 의미도 적용할 수 없으므로 선형 자료구조 아님

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/d37092cf-005d-4973-bff7-1d7572c8bd45)
```python
s1={1, 2, 3}
s2={2, 3, 4, 5}
s3=s1.union(s2)#합집합
s4=s1.intersection(s2)#교집합
s5=s1-s2#차집합

print('s1:', s1)
print('s2:', s2)
print('s3:', s3)
print('s4:', s4)
print('s5:', s5)
```

### 맵(Map)(딕셔너리, Dictionary)
* 자료를 저장하고 탐색키를 이용해 원하는 자료를 빠르게 찾을 수 있도록 하는 탐색을 위한 자료구조
* 맵은 엔트리(entry)라는 키를 가진 레코드(keyed record)의 집합
  * 키(key): 영어단어와 같은 레코드를 구분할 수 있는 탐색키
  * 값(value): 영어 단어의 의미와 같이 탐색키와 관련된 정보들
 
```python
map={'김연아':'피겨', '류현진':'야구', '쿠드롱':'당구', '메시':'축구'}
print(map)
print('쿠드롱이 뭐하는 사람이지?', map['쿠드롱'])

map['나달']='테니스'#맵에 하나의 항목 추가
print(map)

map.update({'최민영':'여자야구', '고진영':'골프'})#여러 항목 추가
print(map)

#in연산자를 이용하면 어떤 키가 딕셔너리에 있는지를 검사할 수 있다
print('쿠드롱: ', '쿠드롱'in map)
print('페더러: ', '페더러'in map)
```
