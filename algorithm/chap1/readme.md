# 1. 알고리즘 개요

## 1.1 알고리즘이란?
* 알고리즘: 해결해야 할 어떤 문제가 주어졌을 때, 이 문제의 해답을 구하기 위한 절차를 순서대로 명확하게 나타낸 것
* 예: 두 컵의 음료 바꾸기

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/fb1b5320-f485-4dd7-add1-3ec2d9364723)
```
1. 새로운 컵 c를 준비한다
2. a의 콜라를 모두 c에 붓는다.
3. b의 사이다를 모두 a에 붓는다.
4. c의 내용물을 b에 모두 붓는다.
```

### 알고리즘의 정의
* 주어진 문제를 해결하기 위한 단계적인 절차
  * 알고리즘은 c언어나 Java, Python 등과 같은 프로그래밍 언어와 상관없이 문제 해결 절차를 나타내는 명령어의 집합
 
![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/32567e69-d260-4ed2-8c73-765a86ca5540)

### 알고리즘의 조건
* 입력: 알고리즘이 입력을 받는다면 모호하지 않고 잘 정의된 입력이어야 한다. 알고리즘은 0개 이상의 입력을 갖는다.
* 출력: 출력은 명확하게 정의되어야 하며 1개 이상의 출력이 반드시 존재하여야 한다.
* 명확성: 각 명령어의 의미는 모호하지 않고 명확해야 한다.
* 유한성: 한정된 수의 단계 후에는 반드시 종료되어야 한다. 즉, 무한루프나 이와 유사한 상태로 끝나서는 안된다.
* 유효성: 명령어들은 현재 실행 가능한 연산이여야 한다. 미래에 개발될 기술 등을 포함해서는 안된다.

### 알고리즘의 기술 방법
1. 자연어 표현
2. flowchart
3. pseudo-code
4. 특정 프로그래밍 언어

### 알고리즘의 기술 예: 배열에서 최댓값을 찾는 알고리즘
1. 자연어 표현
```
find_max(A)
1. 리스트 A의 첫 번째 항목을 변수 max에 복사한다.
2. 리스트 A의 다음 항목들을 차례대로 max와 비교하여, max보다 더 크면 그 값을 max로 복사한다.
3. 배열 A의 모든 요소를 비교했으면 max를 반환한다.
```

2. flowchart

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/ab325bcf-caa2-45ff-879c-3380b7009f45)

3. pseudo-code
```
find_max(A):
  max<-A[0]
  for i<-1 to size(A) do
    if A[i]]>max then
      max<-A[i]
  return max
```

4. 특정 프로그래밍 언어(python)
```python
def find_max(A):
    max=A[0]
    for i in range(len(A)):
        if A[i]>max:
            max=A[i]
    return max

if __name__=='__main__':
    a=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    print(find_max(a))
```
![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/7e31410c-3635-4c9c-a474-29019b97fb1f)

### 문제1.1 최대공약수 문제
> 두 자연수 a와 b의 최대공약수를 구하라. a와 bn의 최대공약수는 a의 약수인 동시에 b의 약수인 숫자 중에서 가장 큰 수를 의미한다.

* 문제 해결을 위해 여러가지 알고리즘이 가능함

1. 정의를 직접 이용
  * 60의 약수: 1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60
  * 28의 약수: 1, 2, 4, 7, 14, 28
  * 공약수: 1, 2, 4
  * 최대공약수: **4**
```
gcd(a, b)
1. a의 약수를 찾아 리스트 alist에 저장
2. b의 약수를 찾아 리스트 blist에 저장
3. alist와 blist에 공통적으로 들어 있는 가장 큰 숫자를 찾아 반환
```

2. 한 수의 약수만 구함
  * 60의 약수: 1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60
  * 28을 60의 약수로 나눈 나머지(28%약수): 0, 3, 4, 8, 4, 13, 8, 28
  * 나누어 떨어지는 가장 큰 약수: 4
```
gcd(a, b)
1. a의 약수를 모두 찾아 리스트 alist에 저장
2. alist의 가장 큰 수부터 차례대로 b의 약수인지를 검사. 만약 b의 약수이기도 하면 이 숫자를 반환
3. 이 과정을 alist의 모든 숫자에 대해 반
```

3. 유클리드 알고리즘
$$gcd(a, b)=gch(b, a mod b)$$

예: gcd(60, 28)=4

gcd(28, 4)=0

gcd(4, 0) -> 4

```python
def gcd(a, b):
  while b!=0:
    r=a%b
    a=b
    b=r
  return a
```

### 알고리즘은 
* 알고리즘은 여러 가지 방법으로 표현할 수 있다.
* 하나의 문제를 해결하기 위해 여러 가지 알고리즘이 가능하다.
* 동일한 문제에 대해 매우 다른 전략을 기반으로 알고리즘을 작성할 수 있고, 이들은 매우 다른 속도로 문제를 해결할 수 있다.
* 알고리즘의 정확한 동작을 위한 제한 조건이나 입력의 범위를 신중하게 고려해야 한다.
  * 예: 유클리드 알고리즘에서는 a가 b보다 커야 한다.
 
---

## 1.2 문제 해결 과정
* 알고리즘 개발 과정
![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/e28c39f3-0ef3-4849-9c94-543074709b94)
