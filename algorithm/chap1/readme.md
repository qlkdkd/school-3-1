# 1. 알고리즘 개요

## 1.1 알고리즘이란?
* 알고리즘: 해결해야 할 어떤 문제가 주어졌을 때, 이 문제의 해답을 구하기 위한 절차를 순서대로 명확하게 나타낸 것
* 예: 두 컵의 음료 바꾸기

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/fb1b5320-f485-4dd7-add1-3ec2d9364723)
```
1. 새로운 컵 c를 준비한다
2. a의 콜라를 모두 c에 붓는다.
3. b의 사이다를 모두 a에 붓는다.
4. c의 내용물을 b에 모두 붓는다.
```

### 알고리즘의 정의
* 주어진 문제를 해결하기 위한 단계적인 절차
  * 알고리즘은 c언어나 Java, Python 등과 같은 프로그래밍 언어와 상관없이 문제 해결 절차를 나타내는 명령어의 집합
 
![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/32567e69-d260-4ed2-8c73-765a86ca5540)

### 알고리즘의 조건
* 입력: 알고리즘이 입력을 받는다면 모호하지 않고 잘 정의된 입력이어야 한다. 알고리즘은 0개 이상의 입력을 갖는다.
* 출력: 출력은 명확하게 정의되어야 하며 1개 이상의 출력이 반드시 존재하여야 한다.
* 명확성: 각 명령어의 의미는 모호하지 않고 명확해야 한다.
* 유한성: 한정된 수의 단계 후에는 반드시 종료되어야 한다. 즉, 무한루프나 이와 유사한 상태로 끝나서는 안된다.
* 유효성: 명령어들은 현재 실행 가능한 연산이여야 한다. 미래에 개발될 기술 등을 포함해서는 안된다.

### 알고리즘의 기술 방법
1. 자연어 표현
2. flowchart
3. pseudo-code
4. 특정 프로그래밍 언어

### 알고리즘의 기술 예: 배열에서 최댓값을 찾는 알고리즘
1. 자연어 표현
```
find_max(A)
1. 리스트 A의 첫 번째 항목을 변수 max에 복사한다.
2. 리스트 A의 다음 항목들을 차례대로 max와 비교하여, max보다 더 크면 그 값을 max로 복사한다.
3. 배열 A의 모든 요소를 비교했으면 max를 반환한다.
```

2. flowchart

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/ab325bcf-caa2-45ff-879c-3380b7009f45)

3. pseudo-code
```
find_max(A):
  max<-A[0]
  for i<-1 to size(A) do
    if A[i]]>max then
      max<-A[i]
  return max
```

4. 특정 프로그래밍 언어(python)
```python
def find_max(A):
    max=A[0]
    for i in range(len(A)):
        if A[i]>max:
            max=A[i]
    return max

if __name__=='__main__':
    a=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    print(find_max(a))
```
![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/7e31410c-3635-4c9c-a474-29019b97fb1f)

### 문제1.1 최대공약수 문제
> 두 자연수 a와 b의 최대공약수를 구하라. a와 bn의 최대공약수는 a의 약수인 동시에 b의 약수인 숫자 중에서 가장 큰 수를 의미한다.

* 문제 해결을 위해 여러가지 알고리즘이 가능함

1. 정의를 직접 이용
  * 60의 약수: 1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60
  * 28의 약수: 1, 2, 4, 7, 14, 28
  * 공약수: 1, 2, 4
  * 최대공약수: **4**
```
gcd(a, b)
1. a의 약수를 찾아 리스트 alist에 저장
2. b의 약수를 찾아 리스트 blist에 저장
3. alist와 blist에 공통적으로 들어 있는 가장 큰 숫자를 찾아 반환
```

2. 한 수의 약수만 구함
  * 60의 약수: 1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60
  * 28을 60의 약수로 나눈 나머지(28%약수): 0, 3, 4, 8, 4, 13, 8, 28
  * 나누어 떨어지는 가장 큰 약수: 4
```
gcd(a, b)
1. a의 약수를 모두 찾아 리스트 alist에 저장
2. alist의 가장 큰 수부터 차례대로 b의 약수인지를 검사. 만약 b의 약수이기도 하면 이 숫자를 반환
3. 이 과정을 alist의 모든 숫자에 대해 반
```

3. 유클리드 알고리즘
$$gcd(a, b)=gch(b, a mod b)$$

예: gcd(60, 28)=4

gcd(28, 4)=0

gcd(4, 0) -> 4

```python
def gcd(a, b):
  while b!=0:
    r=a%b
    a=b
    b=r
  return a
```

### 알고리즘은 
* 알고리즘은 여러 가지 방법으로 표현할 수 있다.
* 하나의 문제를 해결하기 위해 여러 가지 알고리즘이 가능하다.
* 동일한 문제에 대해 매우 다른 전략을 기반으로 알고리즘을 작성할 수 있고, 이들은 매우 다른 속도로 문제를 해결할 수 있다.
* 알고리즘의 정확한 동작을 위한 제한 조건이나 입력의 범위를 신중하게 고려해야 한다.
  * 예: 유클리드 알고리즘에서는 a가 b보다 커야 한다.
 
---

## 1.2 문제 해결 과정
* 알고리즘 개발 과정

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/e28c39f3-0ef3-4849-9c94-543074709b94)

### 문제의 이해
* 문제를 정확히 이해하는 것이 가장 중요
 * 간단한 입력 예에 대한 해를 구해보고, 좀 더 특별한 경우에 대해서도 생각해 보아야 함
* 입력(input)은 주어진 문제의 하나의 사례(instance)
 * 입력의 범위
 * 올바른 알고리즘은 "대부분의 입력"이 아니라 "모든 유효한 입력"에 대해 정확한 해답을 구함
* 알고리즘 설계 전 결정해야 할 사항들
 * 순서적(sequential) 알고리즘/병렬처리(parallel) 알고리즘

### 알고리즘의 설계 기법들
* 억지 기법과 완전 탐색
* 축소정복 
* 분할 정복
* 공간을 이용해 시간을 버는 전략
* 동적 계획법
* 탐욕적 기법
* 백트래킹과 분기 한정 기법

### 알고리즘의 정확성
* 실험적 분석
  * 다양한 입력 적용
  * 충분한 테스트가 어느 정도인지 애매함
  * 알고리즘이 틀렸다는 것을 보여주기 위해서는 한 가지 입력 사례만으로 충분
* 증명적인 분석
  * 수학적인 증명
  * 수학적 귀납법 등
  * 증명이 매우 어려울 수도 있음
 
### 알고리즘의 분석과 구현
* 알고리즘의 효율성 분석
  * 시간 효율성
  * 공간 효율성
  * 코드 효율성
* 알고리즘 구현
  * 특정 프로그래밍 언어
  * 컴파일/인터프리터
 
## 1.3. 중요한 문제의 유형들
### 정렬
![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/fe3a4671-5168-4e6f-a260-3f4aba822cf1)
* 데이터를 순서대로 재배열하는 작업
* 오름차순/내림차순
* 레코드, 정렬 키(key)
* 비교기반, 분배기반
* 안정성 만족/불만족
* 제자길 정렬

### 탐색
* 원하는 값을 가진 레코드를 찾는 작업
* 탐색키
* 순차 탐색, 이진 탐색, 해싱

### 문자열 처리
* 문자열은 문자들의 시퀀스
* 텍스트 문자열/비트 문자열/유전 시퀀스 등
* 문자열 매칭

### 그래프 문제
* 연결된 객체들 사이의 관계를 표현할 수 있는 자료구조
* 다양한 객체(정점)들이 서로 복잡하게 연결(간선)된 구조로 표현
  * 순회(3장)
  * 위상 정렬(4장)
  * 최단경로(7, 8장)
  * 최소비용의 신장트리(8장)
  * TSP, Graph Coloring(9장)
 
### 조합 문제
* 어떤 조건을 만족하는 순열이나 조합 또는 부분 집합과 같은 조합 객체를 찾는 문제
* 예: TSP 문제
  * 모든 가능한 경로(조합 객체) 중에서 최단 경로란 추가적인 특성을 갖는 조합 객체를 찾는 문제
  * 보통 조합 객체의 수가 문제의 크기에 따라 매우 빠르게 증가

## 1.4. 기본적인 자료구조와 파이썬
* 자료구조
  * 자료들을 정리하고 조직화하는 여러 가지 구조
  * 알고리즘 설계에 큰 영향을 미침
  * 단순 자료구조/복합 자료구조
* 배열 구조와 연결된 구조
  * 직접 접근, 순서 접근
  * 파이썬에서의 배열: 리스트(list)와 튜플(tuple)로 구현 가능

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/0105bff8-43c2-460f-89e8-9a8790503c2e)

### 리스트
* 항목들이 순서대로 나열, 각 항목들은 위치를 갖음

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/5df5af17-8de4-4f7d-8826-9137d6414a62)
* 파이썬에서 자료구조 '리스트'가 필요하면 파이썬 리스트를 사용할 수 있음
* 파이썬 리스트란?
  * 자료구조 리스트를 배열 구조로 구현한 클래스
  * 가장 많이 사용됨
  * 용량을 늘릴 수 있음: 동적 배열
 
### 스택
* 후입선출(LIFO: Last In First Out)

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/8adf3aed-d23e-4f8e-9a81-76a98f68bac8)
* 파이썬에서 스택이 필요하면?
  1. 파이썬 리스트 이용
  2. 큐 모듈(queue)의 `LifoQueue`클래스 사용
  3. 직접 클래스로 구현해서 사용
 
### 큐
* 선입선출(FIFO: First In First Out)

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/80dd2938-5b58-40ba-aeec-8a805623f041)
* 파이썬에서 큐가 필요하면?
 1. 큐 모듈(queue)의 `Queue`클래스 사용
 2. 직접 클래스로 구현해서 사용

### 우선순위 큐
* 우선순위의 개념을 큐에 도입한 자료구조
  * 선형 자료구조가 아님
  * 힙(heap)이 가장 효율적인 구현 방법
 
![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/a101145b-782b-475c-8cbd-9af21fef28e4)
  * 파이썬에서 우선순위 큐가 필요하면 heapq모듈 사용

### 그래프
* G=(V, E)
  * V: 정점, 객체를 표현
  * E: 간선, 객체들 사이의 관계
* 그래프의 종류

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/66198437-bdf4-4a34-8348-96cc3d5161f8)
* 방향 그래프
* 무방향 그래프
* 가중치 그래프

#### 그래프 용어
* 인접 정점: 간선에 의해 직접 연결된 정점
* 정점의 차수: 정점에 연결된 간선의 수
  * 무방향 그래프에서는 단순히 인접한 정점의 수
  * 방향 그래프: 진입 차수, 진출 차수로 나뉨
* 경로: 간선을 따라갈 수 있는 길. 정점의 나열로 표시
* 경로의 길이: 경로를 구성하는 데 사용된 간선의 수
* 단순 경로와 사이클
  * 단순 경로: 반복되는 간선이 없는 경로
  * 사이클: 단순 경로의 시작 정점과 종료 정점이 같은 경우
* 연결 그래프: 모든 정점들 사이에 경로가 존재하는 그래프
* 트리: 사이클을 가지지 않는 연결 그래프
* 완전 그래프: 모든 정점 간에 간선이 존재하는 그래프

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/205f9341-6125-43db-be66-a6951591707f)

### 트리
* 자유트리: 사이클이 없는 연결 그래프
* 루트를 가진 트리: 자유 트리의 정점들 중에 하나를 루트로 선택

![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/649d1826-7d1d-4899-ac4c-dacfd5bba71a)
![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/ea1101b6-4765-4024-8124-e20b3207de2f)
* 트리의 표현
  * 일반 트리
  * 이진 트리
    * 배열 구조/연결된 구조

### 집합
* 원소들 사이에 순서가 없고, 중복을 허용하지 않음
  * 선형 자료구조가 아님
  * 위치가 없음
 
![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/407084bf-6526-416b-a1e4-745622c3a3c7)

### 맵 또는 딕셔너리
* 탐색을 위한 자료구조
* 키를 가진 레코드 또는 엔트리의 집합
  * 엔트리
    * 키(key): 레코드를 구분할 수 있는 탐색키
    * 값(value): 탐색키와 관련된 정보들
   
![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/85095e43-4439-41b0-96e5-af4d2c5e2ccf)
![image](https://github.com/qlkdkd/univ-3-1/assets/71871927/22df07fa-6d01-415a-99f4-7b62b11c077a)
**
